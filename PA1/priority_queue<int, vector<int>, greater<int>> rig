priority_queue<int, vector<int>, greater<int>> right;
 vector<vector<int>> dir{{-1, 0}, {0, 1}, {0, -1}, {1, 0}};
sort(courses.begin(), courses.end(), [](vector<int> &v1, vector<int> &v2){return v1[1] < v2[1];});
struct TrieNode{
    vector<TrieNode*> child;
    string word;
    TrieNode() : word(""), child(vector<TrieNode *>(26, nullptr)) {}
};
 vector<vector<int>> dis(m, vector<int>(n, INT_MAX));

 queue.front();
 queue.back();
 queue.pop();
 queue.push();
 queue<pair<int, int>> q;
 q.push({start[0], start[1]});

stack.top();
stack.pop();
stack.push();

priority_queue.top()
push();
pop();

struct compC{
    bool operator()(pair<int, int> &a, pair<int, int> &b) {
        return a.first > b.first;
    }
};
priority_queue<pair<int, int>, vector<pair<int, int>>, compC> cap; // minheap

deque.push_back();
deque.push_front();
deque.pop_back();
deque.poo_front();
deque.front();
deque.back();

deque.erase(pointer);
pointer can be begin(), end(), rbegin();

set :lower_bound() first element larger or equal to the element;
set: upper_bound() first element larger to the given element;

a.insert(a.end(), b.begin(), b.end());

 vector<Interval> merge(vector<Interval>& intervals) {
        if(intervals.empty()) return vector<Interval>{};
        vector<Interval> res;
        sort(intervals.begin(), intervals.end(), [](Interval a, Interval b){return a.start < b.start;});
        res.push_back(intervals[0]);
        for(int i = 1; i < intervals.size(); i++){
            if(res.back().end < intervals[i].start) res.push_back(intervals[i]);
            else{
                res.back().end = max(res.back().end, intervals[i].end);
            }
        }
        return res;
     }

struct CustomCompare
{
    bool operator()(const int& lhs, const int& rhs)
    {
        return lhs < rhs;
    }
};


priority_queue<int,vector<int>, CustomCompare > pq;
stringstream in(string);
    string val;
       // in >> val;
        getline(in, val, ',');

